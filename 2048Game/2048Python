import random
import tkinter as tk
import tkinter.messagebox
import time

class Game2048:
    def __init__(self):
        self.board = self.initialize_board()
        self.window = tk.Tk()
        self.window.title("2048 Game")
        self.cells = [[None for _ in range(4)] for _ in range(4)]
        self.create_grid()
        self.update_grid()
        self.window.bind("<Key>", self.handle_keypress)
        self.window.bind("<ButtonPress-1>", self.on_mouse_press)
        self.window.bind("<ButtonRelease-1>", self.on_mouse_release)
        self.start_x = None
        self.start_y = None
        self.window.mainloop()

    def initialize_board(self):
        board = [[0] * 4 for _ in range(4)]
        self.add_random_tile(board)
        self.add_random_tile(board)
        return board

    def add_random_tile(self, board):
        empty_cells = [(r, c) for r in range(4) for c in range(4) if board[r][c] == 0]
        if empty_cells:
            r, c = random.choice(empty_cells)
            board[r][c] = 4 if random.random() < 0.1 else 2

    def create_grid(self):
        for r in range(4):
            for c in range(4):
                frame = tk.Frame(
                    self.window,
                    width=100,
                    height=100,
                    bg="lightgray",
                    bd=3,
                    relief="raised"
                )
                frame.grid(row=r, column=c, padx=5, pady=5)
                label = tk.Label(self.window, text="", font=("Helvetica", 24), width=4, height=2)
                label.grid(row=r, column=c)
                self.cells[r][c] = label

    def update_grid(self):
        for r in range(4):
            for c in range(4):
                value = self.board[r][c]
                label = self.cells[r][c]
                if value == 0:
                    label.config(text="", bg="lightgray")
                else:
                    label.config(text=str(value), bg="orange", fg="black")

    def slide_left(self, row):
        new_row = [i for i in row if i != 0]
        new_row += [0] * (4 - len(new_row))
        return new_row

    def combine_row(self, row):
        for i in range(3):
            if row[i] == row[i + 1] and row[i] != 0:
                row[i] *= 2
                row[i + 1] = 0
        return row

    def move_left(self, board):
        new_board = []
        for row in board:
            new_row = self.slide_left(row)
            new_row = self.combine_row(new_row)
            new_row = self.slide_left(new_row)
            new_board.append(new_row)
        return new_board

    def rotate_board(self, board):
        return [list(row) for row in zip(*board[::-1])]

    def move(self, direction):
        if direction == 'w':
            self.board = self.rotate_board(self.board)
            self.board = self.rotate_board(self.board)
            self.board = self.rotate_board(self.board)
            self.board = self.move_left(self.board)
            self.board = self.rotate_board(self.board)
        elif direction == 's':
            self.board = self.rotate_board(self.board)
            self.board = self.move_left(self.board)
            self.board = self.rotate_board(self.board)
            self.board = self.rotate_board(self.board)
            self.board = self.rotate_board(self.board)
        elif direction == 'a':
            self.board = self.move_left(self.board)
        elif direction == 'd':
            self.board = self.rotate_board(self.board)
            self.board = self.rotate_board(self.board)
            self.board = self.move_left(self.board)
            self.board = self.rotate_board(self.board)
            self.board = self.rotate_board(self.board)

    def check_game_over(self):
        for row in self.board:
            if 0 in row:
                return False
        for r in range(4):
            for c in range(3):
                if self.board[r][c] == self.board[r][c + 1]:
                    return False
        for r in range(3):
            for c in range(4):
                if self.board[r][c] == self.board[r + 1][c]:
                    return False
        return True

    def handle_keypress(self, event):
        if event.keysym in ['w', 'a', 's', 'd']:
            old_board = [row[:] for row in self.board]
            self.move(event.keysym)
            if old_board != self.board:
                self.animate_slide(old_board, self.board)
                self.add_random_tile(self.board)
                self.update_grid()
                if self.check_game_over():
                    tk.messagebox.showinfo("Game Over", "Game Over!")

    def on_mouse_press(self, event):
        self.start_x = event.x
        self.start_y = event.y

    def on_mouse_release(self, event):
        end_x = event.x
        end_y = event.y
        dx = end_x - self.start_x
        dy = end_y - self.start_y

        if abs(dx) > abs(dy):
            if dx > 0:
                direction = 'd'
            else:
                direction = 'a'
        else:
            if dy > 0:
                direction = 's'
            else:
                direction = 'w'

        old_board = [row[:] for row in self.board]
        self.move(direction)
        if old_board != self.board:
            self.animate_slide(old_board, self.board)
            self.add_random_tile(self.board)
            self.update_grid()
            if self.check_game_over():
                tk.messagebox.showinfo("Game Over", "Game Over!")

    def animate_slide(self, old_board, new_board):
        steps = 20  # Increase steps for smoother animation
        for step in range(1, steps + 1):
            intermediate_board = [[0] * 4 for _ in range(4)]
            for r in range(4):
                for c in range(4):
                    if new_board[r][c] != 0 and old_board[r][c] != new_board[r][c]:
                        old_r, old_c = None, None
                        for orow in range(4):
                            for ocol in range(4):
                                if old_board[orow][ocol] == new_board[r][c] and intermediate_board[orow][ocol] == 0:
                                    old_r, old_c = orow, ocol
                                    break
                            if old_r is not None:
                                break
                        if old_r is not None:
                            dr = (r - old_r) * step / steps
                            dc = (c - old_c) * step / steps
                            intermediate_board[int(old_r + dr)][int(old_c + dc)] = new_board[r][c]
                        else:
                            intermediate_board[r][c] = new_board[r][c]
                    else:
                        intermediate_board[r][c] = new_board[r][c]
            self.board = intermediate_board
            self.update_grid()
            self.window.update()
            time.sleep(0.02)  # Decrease sleep time for smoother appearance

if __name__ == "__main__":
    Game2048()